# This is a basic workflow to help you get started with Actions
name: Docker build

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    # Run on wednesday at 3am UTC
    - cron: 0 3 * * 3

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Cancel old builds on PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  BASE_UBUNTU_VERSION: "20.04"
  TARGET_UBUNTU_VERSION: "22.04"

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  set-vars:
    runs-on: ubuntu-latest
    steps:
      - name: Get tags
        id: gather_data
        run: |
          TAG_DATE=day-$(date +'%Y%d%m')
          TAG_RUN_ID=run-${GITHUB_RUN_ID}
          TAG_SHORT_SHA=${GITHUB_SHA:0:7}

          echo "::set-output name=TAG_DATE::${TAG_DATE}"
          echo "::set-output name=TAG_RUN_ID::${TAG_RUN_ID}"
          echo "::set-output name=TAG_SHORT_SHA::${TAG_SHORT_SHA}"

          echo TAG_DATE=${TAG_DATE}
          echo TAG_RUN_ID=${TAG_RUN_ID}
          echo TAG_SHORT_SHA=${TAG_SHORT_SHA}


    outputs:
      TAG_DATE: ${{ steps.gather_data.outputs.TAG_DATE }}
      TAG_RUN_ID: ${{ steps.gather_data.outputs.TAG_RUN_ID }}
      TAG_SHORT_SHA: ${{ steps.gather_data.outputs.TAG_SHORT_SHA }}

  build-base:
    
    needs: set-vars
    runs-on: packer
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v3

      - name: Build base image
        env:
          DOCKER_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
          DOCKER_BUILDKIT: 1
          TAG_DATE: ${{ needs.set-vars.outputs.TAG_DATE }}
          TAG_RUN_ID: ${{ needs.set-vars.outputs.TAG_RUN_ID }}
          TAG_SHORT_SHA: ${{ needs.set-vars.outputs.TAG_SHORT_SHA }}

        run: |
          echo ${DOCKER_PASSWORD} | docker login ghcr.io --username USERNAME --password-stdin

          git clone https://github.com/actions-runner-controller/actions-runner-controller.git
          cd actions-runner-controller/runner

          # Gather your own SHA for the base image (upstream repo)
          export COMMIT_SHA="base-$(git rev-parse --short HEAD)"

          sed -i "s/ubuntu:${BASE_UBUNTU_VERSION}/ubuntu:${TARGET_UBUNTU_VERSION}/g" actions-runner-dind.dockerfile
          docker buildx build \
            --no-cache \
            --build-arg "TARGETPLATFORM=linux/amd64" \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:latest \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:ubuntu22 \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:22.04 \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:${COMMIT_SHA} \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:${TAG_DATE} \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:${TAG_RUN_ID} \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:${TAG_SHORT_SHA} \
            --tag ghcr.io/a1ebd7cc0eb3/runner-base:commit-${TAG_SHORT_SHA} \
            --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}" \
            --file actions-runner-dind.dockerfile \
            .

          docker push ghcr.io/a1ebd7cc0eb3/runner-base:latest
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:ubuntu22
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:22.04
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:${COMMIT_SHA} 
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:${TAG_DATE}
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:${TAG_RUN_ID}
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:${TAG_SHORT_SHA}
          docker push ghcr.io/a1ebd7cc0eb3/runner-base:commit-${TAG_SHORT_SHA}

  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: packer
    needs: [set-vars, build-base]
    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - uses: actions/checkout@v3

      # Runs a single command using the runners shell
      - name: Docker build image & upload
        working-directory: "./images/linux"
        env:
          DOCKER_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
          DOCKER_BUILDKIT: 1
          TAG_DATE: ${{ needs.set-vars.outputs.TAG_DATE }}
          TAG_RUN_ID: ${{ needs.set-vars.outputs.TAG_RUN_ID }}
          TAG_SHORT_SHA: ${{ needs.set-vars.outputs.TAG_SHORT_SHA }}
          RETRIES: 3
        run: |
          echo ${DOCKER_PASSWORD} | docker login ghcr.io --username USERNAME --password-stdin 

          set +e

          # Sometimes the image fails to build but succeeds when retrying the job, automate that
          while [ ${RETRIES} -gt 0 ] ; do
            docker buildx build \
              --no-cache \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:latest \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:ubuntu22 \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:22.04 \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_DATE} \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_RUN_ID} \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_SHORT_SHA} \
              --tag ghcr.io/a1ebd7cc0eb3/runner-images:commit-${TAG_SHORT_SHA} \
              --label "org.opencontainers.image.source=https://github.com/${GITHUB_REPOSITORY}" \
            .
            EXIT_CODE=$?
            if [ "${EXIT_CODE}" == "0" ]; then
              break
            fi

            let "RETRIES=RETRIES-1"
            if [ "${RETRIES}" == "0" ] && [ "${EXIT_CODE}" != "0" ]; then
              echo "ERROR: Docker image build failed ${RETRIES} times"
              exit ${EXIT_CODE}
            else
              echo "ERROR: Docker image build failed, trying again"
            fi
            sleep 10
          done
          set -e

          docker push ghcr.io/a1ebd7cc0eb3/runner-images:latest
          docker push ghcr.io/a1ebd7cc0eb3/runner-images:ubuntu22
          docker push ghcr.io/a1ebd7cc0eb3/runner-images:22.04
          docker push ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_DATE}
          docker push ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_RUN_ID}
          docker push ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_SHORT_SHA}
          docker push ghcr.io/a1ebd7cc0eb3/runner-images:commit-${TAG_SHORT_SHA}

          # packer init  ubuntu2204-docker.pkr.hcl
          # packer build \
          #   -var "registry_details={ login=\"true\", login_username=\"USERNAME\", login_server = \"ghcr.io\", login_password=\"${DOCKER_PASSWORD}\" }" \
          #   -var "commit_sha=${COMMIT_SHA}" \
          #   ubuntu2204-docker.pkr.hcl

#   scan-base:
#     runs-on: packer
#     needs: [set-vars, build-base]
#     steps:
#       - uses: actions/checkout@v3
#       - name: Snyk scan base image
#         env:
#           SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
#           DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
#         run: |
#           echo ${DOCKER_PASSWORD} | docker login ghcr.io --username USERNAME --password-stdin
#           docker scan --login --token ${SNYK_TOKEN}
#           # Scan exit code is 1 if finds results, force to be zero
#           docker scan \
#             --accept-license \
#             --json \
#             --group-issues \
#             --severity=high \
#             ghcr.io/a1ebd7cc0eb3/runner-base:latest \
#             | tee base-scan.json \
#             || true
          # Would like to output serif

  export-readme:
    runs-on: packer
    needs: [set-vars, build]
    steps:
      - uses: actions/checkout@v3
        with:
          ref: "with_dockerfile"
      - name: Get installed files
        working-directory: "./images/linux"
        env: 
          TAG_SHORT_SHA: ${{ needs.set-vars.outputs.TAG_SHORT_SHA }}
        run: |
          docker buildx build \
            --build-arg "tag=${TAG_SHORT_SHA}" \
            --file Dockerfile.copy-out \
            --output generated \
            .
          
          # ${TARGET_UBUNTU_VERSION//./} --> shell string expansion to find and replace '.' with ''
          TARGET_FILE="Ubuntu${TARGET_UBUNTU_VERSION//./}-Docker-Readme.md"

          cp generated/Ubuntu-Readme.md ./${TARGET_FILE}
          rm -rf generated

          # Check if the readme has changed, if so push it back
          if [ -n "$(git --no-pager diff ${TARGET_FILE})" ]; then
            git add ${TARGET_FILE}
            git config --global user.name 'Actions'
            git config --global user.email 'actions@users.noreply.github.com'
            git commit -am 'Update package list'
            git push
          fi
      - name: Update summary
        working-directory: "./images/linux"
        run: |
          TARGET_FILE="Ubuntu${TARGET_UBUNTU_VERSION//./}-Docker-Readme.md"
          cat ${TARGET_FILE} >> $GITHUB_STEP_SUMMARY



    #docker buildx build --build-arg "tag=6f81e09" --file Dockerfile.copy-out --output generated .
#   scan:
#     runs-on: packer
#     needs: [set-vars, build]
#     steps:
#       - uses: actions/checkout@v3
#       - name: Snyk scan
#         env:
#           SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
#           DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
#           TAG_SHORT_SHA: ${{ needs.set-vars.outputs.TAG_SHORT_SHA }}
#         run: |
#           echo ${DOCKER_PASSWORD} | docker login ghcr.io --username USERNAME --password-stdin
#           docker scan --login --token ${SNYK_TOKEN}
#           # Scan exit code is 1 if finds results, force to be zero
#           docker scan \
#             --accept-license \
#             --json \
#             --group-issues \
#             --severity=high \
#             --exclude-base \
#             --file images/linux/Dockerfile \
#             ghcr.io/a1ebd7cc0eb3/runner-images:${TAG_SHORT_SHA} \
#             | tee runner-scan.json \
#             || true
#           # docker scan --accept-license --json --group-issues --severity=high --exclude-base --file images/linux/Dockerfile ghcr.io/a1ebd7cc0eb3/runner-images:latest || true
#           # Would like to output serif

